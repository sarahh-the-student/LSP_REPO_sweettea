# Reflection on Object-Oriented Refactoring

**What is different about the design?**

The primary difference between the designs of my Assignment 2 and Assignment 3 implementations is the fundamental shift from a monolithic, procedural structure to a decomposed, object-oriented one. My initial implementation for Assignment 2 was contained within a single `ETL.java` file. This single class handled every aspect of the program, from file input/output to data transformation and summary reporting. The logic was organized into `private static` methods, and the program’s state, like row counters, was stored in `private static` variables. This design was simple and functional, but it was also rigid, with all the components tightly coupled together.

The Assignment 3 design, by contrast, is a modular system of collaborating classes. I broke down the single `ETL` class into several smaller, focused classes, each adhering to the Single Responsibility Principle. The `EtlDriver` class now contains the `main` method and serves as the orchestrator of the entire process. The actual work is delegated to specialized objects: `CsvExtractor` is responsible for reading data, `ProductTransformer` handles all the business logic, and `CsvLoader` is dedicated to writing the output. Additionally, `Product` was promoted to its own public class, and a new `RunSummary` class was created to properly manage the program’s state, resulting in a much cleaner and more organized architecture.

**How is Assignment 3 more object-oriented?**

My Assignment 3 design is fundamentally more object-oriented because it is built as a system of interacting objects rather than a linear script. This approach leads to a more modular, reusable, and maintainable application. The clear separation of concerns is a major factor; in Assignment 3, each object has a distinct job. The `CsvExtractor` doesn’t need to know how data is transformed, and the `ProductTransformer` doesn’t care where the data came from. This decoupling means a change to one part of the system is less likely to break another. For example, if I wanted to change the transformation rules, I would only need to edit `ProductTransformer.java`.

Furthermore, the management of state is far more robust. The static variables in Assignment 2 acted like global variables, which can be a common source of bugs. By creating a `RunSummary` object in Assignment 3, the state of the ETL run is contained within an instance that is explicitly passed to the methods that need it. This makes the flow of data clear and controlled. This design also greatly improves reusability. The `CsvLoader` class, for instance, could be reused in a completely different project, and the `ProductTransformer` could be applied to data from a database, as it is no longer tied to file-reading logic.

**Which OO ideas (object, class, encapsulation, inheritance, polymorphism) did you use?**

In this refactoring project, I primarily utilized the core concepts of **object**, **class**, and **encapsulation**. The entire design of Assignment 3 is built upon the idea of **classes** serving as blueprints for **objects**. The `EtlDriver` creates instances (objects) of `CsvExtractor`, `ProductTransformer`, `CsvLoader`, and `RunSummary`, and then directs these objects to interact with each other to accomplish the task. This is a significant departure from the static, function-based approach of Assignment 2.

**Encapsulation** was the most impactful OO principle I implemented. The `RunSummary` class is the clearest example of this. It encapsulates, or bundles, the run statistics (the data) with the methods that operate on that data (`incrementRowsRead()`, `print()`). By making the counter fields `private`, I hid the internal state from the outside world. The only way to interact with the data is through the `public` methods I provided. This protects the data from being changed in unexpected ways and is a hallmark of strong object-oriented design. The concepts of **inheritance** and **polymorphism** were not used in this assignment, as the problem did not require creating parent-child class relationships or designing for interchangeable components. However, I recognize that a future version could use polymorphism, such as an `ITransformer` interface, to allow for different sets of transformation rules to be swapped in and out.

**Explain how you tested to confirm Assignment 3 works the same as Assignment 2.**

To confirm that the refactored program still produced the exact same results and handled errors identically, I implemented a two-part testing strategy covering both normal operation and error conditions. For the "happy path" test, I created a sample `products.csv` input file containing data that would trigger all the different transformation rules. After running the Assignment 3 program, I opened the generated `data/transformed_products.csv` and compared its contents line by line against the known correct output. This allowed me to verify that the business logic for uppercasing names, applying discounts, re-categorizing products, and assigning price ranges was still functioning perfectly.

For the "sad path" testing, I focused on error handling. First, I tested the missing file scenario by temporarily renaming my `products.csv` file and running the program. I confirmed that the application printed the expected `Error: Missing input file...` message to the console and exited gracefully. Second, I tested for malformed data by editing the input file to include invalid rows, such as one with text in the price column. I ran the program again and verified that it printed the "Skipping malformed row..." message for the invalid line but still successfully processed all the valid lines. These tests confirmed that the external behavior of the Assignment 3 program was identical to that of Assignment 2, proving the refactoring was a success.